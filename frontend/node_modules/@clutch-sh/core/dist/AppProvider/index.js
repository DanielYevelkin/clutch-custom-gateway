import React from "react";
import { BrowserRouter as Router, Outlet, Route, Routes } from "react-router-dom";
import Bugsnag from "@bugsnag/js";
import BugsnagPluginReact from "@bugsnag/plugin-react";
import AppLayout from "../AppLayout";
import { ApplicationContext, ShortLinkContext } from "../Contexts";
import { Toast } from "../Feedback";
import { FEATURE_FLAG_POLL_RATE, featureFlags } from "../flags";
import Landing from "../landing";
import NotFound from "../not-found";
import { registeredWorkflows } from "./registrar";
import ShortLinkProxy, { ShortLinkBaseRoute } from "./short-link-proxy";
import ShortLinkStateHydrator from "./short-link-state-hydrator";
import { Theme } from "./themes";
import ErrorBoundary from "./workflow";
/**
 * Filter workflow routes using available feature flags.
 * @param workflows a list of valid Workflow objects.
 */
const featureFlagFilter = (workflows) => {
    return featureFlags().then(flags => workflows.filter(workflow => {
        /* eslint-disable-next-line no-param-reassign */
        workflow.routes = workflow.routes.filter(route => {
            const show = route.featureFlag === undefined ||
                ((flags === null || flags === void 0 ? void 0 : flags[route.featureFlag]) !== undefined &&
                    flags[route.featureFlag].booleanValue === true);
            return show;
        });
        return workflow.routes.length !== 0;
    }));
};
const ClutchApp = ({ availableWorkflows, configuration: userConfiguration, appConfiguration, }) => {
    var _a;
    const [workflows, setWorkflows] = React.useState([]);
    const [isLoading, setIsLoading] = React.useState(true);
    const [workflowSessionStore, setWorkflowSessionStore] = React.useState();
    const [hydrateState, setHydrateState] = React.useState(null);
    const [hydrateError, setHydrateError] = React.useState(null);
    const [hasCustomLanding, setHasCustomLanding] = React.useState(false);
    const [triggeredHeaderData, setTriggeredHeaderData] = React.useState();
    /** Used to control a race condition from displaying the workflow and the state being updated with the hydrated data */
    const [shortLinkLoading, setShortLinkLoading] = React.useState(false);
    const loadWorkflows = () => {
        registeredWorkflows(availableWorkflows, userConfiguration, [featureFlagFilter]).then(w => {
            setWorkflows(w);
            setIsLoading(false);
        });
    };
    React.useEffect(() => {
        loadWorkflows();
        const interval = setInterval(loadWorkflows, FEATURE_FLAG_POLL_RATE);
        return () => clearInterval(interval);
    }, []);
    const [discoverableWorkflows, setDiscoverableWorkflows] = React.useState([]);
    React.useEffect(() => {
        const landingWorkflows = workflows.filter(workflow => workflow.path === "");
        if (landingWorkflows.length > 0) {
            /** Used to control a custom landing page */
            setHasCustomLanding(true);
        }
        setDiscoverableWorkflows(workflows);
    }, [workflows]);
    const shortLinkProviderProps = React.useMemo(() => ({
        removeWorkflowSession: () => setWorkflowSessionStore(null),
        retrieveWorkflowSession: () => workflowSessionStore,
        storeWorkflowSession: setWorkflowSessionStore,
    }), [workflowSessionStore]);
    const appContextValue = React.useMemo(() => ({
        workflows: discoverableWorkflows,
        triggerHeaderItem: (item, data) => 
        // Will set the open status and spread any additional data onto the property named after the item
        setTriggeredHeaderData({
            ...triggeredHeaderData,
            [item]: data,
        }),
        triggeredHeaderData,
    }), [discoverableWorkflows, triggeredHeaderData]);
    return (React.createElement(Router, null,
        React.createElement(Theme, { variant: "light" },
            React.createElement("div", { id: "App" },
                React.createElement(ApplicationContext.Provider, { value: appContextValue },
                    React.createElement(ShortLinkContext.Provider, { value: shortLinkProviderProps },
                        hydrateError && (React.createElement(Toast, { onClose: () => setHydrateError(null) },
                            "Unable to retrieve short link: ", (_a = hydrateError === null || hydrateError === void 0 ? void 0 : hydrateError.status) === null || _a === void 0 ? void 0 :
                            _a.text)),
                        React.createElement(Routes, null,
                            React.createElement(Route, { path: "/", element: React.createElement(AppLayout, { isLoading: isLoading, configuration: appConfiguration }) },
                                !hasCustomLanding && React.createElement(Route, { key: "landing", path: "", element: React.createElement(Landing, null) }),
                                workflows.map((workflow) => {
                                    const workflowPath = workflow.path.replace(/^\/+/, "").replace(/\/+$/, "");
                                    const workflowKey = workflow.path.split("/")[0];
                                    return (React.createElement(Route, { path: `${workflowPath}/`, key: workflowKey, element: React.createElement(ErrorBoundary, { workflow: workflow },
                                            React.createElement(ShortLinkStateHydrator, { sharedState: hydrateState, clearTemporaryState: () => setHydrateState(null) }, !shortLinkLoading && React.createElement(Outlet, null))) },
                                        workflow.routes.map(route => {
                                            const heading = route.displayName
                                                ? `${workflow.displayName}: ${route.displayName}`
                                                : workflow.displayName;
                                            return (React.createElement(Route, { key: workflow.path, path: `${route.path.replace(/^\/+/, "").replace(/\/+$/, "")}`, element: React.cloneElement(React.createElement(route.component, null), {
                                                    ...route.componentProps,
                                                    heading,
                                                }) }));
                                        }),
                                        React.createElement(Route, { key: `${workflow.path}/notFound`, path: "*", element: React.createElement(NotFound, null) })));
                                }),
                                React.createElement(Route, { key: "short-links", path: `/${ShortLinkBaseRoute}/:hash`, element: React.createElement(ShortLinkProxy, { setLoading: setShortLinkLoading, hydrate: setHydrateState, onError: setHydrateError }) }),
                                React.createElement(Route, { key: "notFound", path: "*", element: React.createElement(NotFound, null) })))))))));
};
const BugSnagApp = props => {
    if (process.env.REACT_APP_BUGSNAG_API_TOKEN) {
        // eslint-disable-next-line no-underscore-dangle
        if (!Bugsnag._client) {
            Bugsnag.start({
                apiKey: process.env.REACT_APP_BUGSNAG_API_TOKEN,
                plugins: [new BugsnagPluginReact()],
                releaseStage: process.env.APPLICATION_ENV || "production",
            });
        }
        const BugsnagBoundary = Bugsnag.getPlugin("react").createErrorBoundary(React);
        return (React.createElement(BugsnagBoundary, null,
            React.createElement(ClutchApp, Object.assign({}, props))));
    }
    return React.createElement(ClutchApp, Object.assign({}, props));
};
export default BugSnagApp;
