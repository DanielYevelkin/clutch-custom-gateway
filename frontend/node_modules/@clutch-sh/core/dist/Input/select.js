import * as React from "react";
import styled from "@emotion/styled";
import ErrorIcon from "@mui/icons-material/Error";
import ExpandMoreIcon from "@mui/icons-material/ExpandMore";
import { FormControl as MuiFormControl, FormHelperText as MuiFormHelperText, InputLabel as MuiInputLabel, ListSubheader, MenuItem, Select as MuiSelect, } from "@mui/material";
import { flatten } from "lodash";
import { Chip } from "../chip";
const StyledFormHelperText = styled(MuiFormHelperText)({
    alignItems: "center",
    display: "flex",
    position: "relative",
    fontSize: "12px",
    lineHeight: "16px",
    marginTop: "7px",
    marginLeft: "0px",
    color: "grey",
    "&.Mui-error": {
        color: "#db3615",
    },
    svg: {
        height: "16px",
        width: "16px",
        marginRight: "4px",
    },
});
const StyledInputLabel = styled(MuiInputLabel)({
    "--label-default-color": "rgba(13, 16, 48, 0.6)",
    color: "var(--label-default-color)",
    "&.Mui-focused": {
        color: "var(--label-default-color)",
    },
    "&.Mui-error": {
        color: "#db3615",
    },
});
const SelectIcon = (props) => (React.createElement("div", Object.assign({}, props),
    React.createElement(ExpandMoreIcon, null)));
const BaseSelect = ({ className, ...props }) => (React.createElement(MuiSelect, Object.assign({ fullWidth: true, IconComponent: SelectIcon, className: className, MenuProps: {
        classes: {
            list: className,
            paper: className,
        },
        anchorOrigin: { vertical: "bottom", horizontal: "left" },
        transformOrigin: { vertical: "top", horizontal: "left" },
    } }, props)));
const StyledSelect = styled(BaseSelect)({
    "--notched-border-width": "1px",
    padding: "0",
    backgroundColor: "#FFFFFF",
    minWidth: "fit-content",
    ".MuiOutlinedInput-notchedOutline": {
        borderColor: "rgba(13, 16, 48, 0.38)",
        borderWidth: "var(--notched-border-width)",
    },
    "&.Mui-focused": {
        "> .MuiSelect-icon > svg": {
            color: "#0d1030",
        },
        "> .MuiOutlinedInput-notchedOutline": {
            borderColor: "#3458d4",
            borderWidth: "var(--notched-border-width)",
        },
    },
    "&.Mui-error > .MuiOutlinedInput-notchedOutline": {
        borderColor: "#db3615",
        borderWidth: "var(--notched-border-width)",
    },
    ".MuiSelect-select": {
        height: "20px",
        display: "flex",
        padding: "15px 60px 13px 16px",
        ":focus": {
            backgroundColor: "inherit",
        },
        "&.Mui-disabled": {
            backgroundColor: "rgba(13, 16, 48, 0.12)",
        },
    },
    ul: {
        borderRadius: "4px",
        border: "1px solid rgba(13, 16, 48, 0.1)",
    },
    ".MuiMenuItem-root": {
        color: "#0d1030",
        height: "48px",
        ":first-of-type": {
            borderRadius: "4px 4px 0 0",
        },
        ":last-child": {},
        ":hover": {
            backgroundColor: "#e7e7ea",
        },
        ":active": {
            backgroundColor: "#dbdbe0",
        },
        "&.Mui-selected": {
            backgroundColor: "rgba(53, 72, 212, 0.1)",
            ":hover": {
                backgroundColor: "rgba(53, 72, 212, 0.1)",
            },
        },
    },
    "&.MuiMenu-paper": {
        marginTop: "5px",
        border: "none",
        boxShadow: "0px 5px 15px rgba(53, 72, 212, 0.2)",
        maxHeight: "25vh",
    },
    ".MuiSelect-icon": {
        height: "100%",
        width: "48px",
        top: "unset",
        transform: "unset",
        display: "flex",
        justifyContent: "flex-end",
        alignItems: "center",
        boxSizing: "border-box",
        "> svg": {
            color: "rgba(13, 16, 48, 0.6)",
            position: "absolute",
        },
        "&.MuiSelect-iconOpen > svg": {
            transform: "rotate(180deg)",
        },
        "&.Mui-disabled > svg": {
            color: "rgba(13, 16, 48, 0.6)",
        },
    },
    ".MuiListSubheader-root": {
        color: "#939495",
        cursor: "default",
        pointerEvents: "none", // disables the select from closing on clicking the subheader
    },
});
const flattenBaseSelectOptions = (options) => flatten(options.map((option) => option.group ? option.group.map(groupOption => groupOption) : option));
const menuItemFromOption = (option) => (React.createElement(MenuItem, { key: option.label, value: (option === null || option === void 0 ? void 0 : option.value) || option.label },
    (option === null || option === void 0 ? void 0 : option.startAdornment) &&
        React.cloneElement(option.startAdornment, {
            style: {
                height: "100%",
                maxHeight: "20px",
                marginRight: "8px",
                ...option.startAdornment.props.style,
            },
        }),
    option.label));
const renderSelectItems = (option) => {
    if (option.group) {
        return [
            React.createElement(ListSubheader, null, option.label),
            option.group.map(opt => menuItemFromOption(opt)),
        ];
    }
    return menuItemFromOption(option);
};
// Will take an array of strings or integers and attempt to find the indexes where they exist based on the flattened items
const calculateDefaultOptions = (defaultOptions, flattenedOptions) => {
    const options = [];
    if (defaultOptions === undefined || defaultOptions.length === 0) {
        return options;
    }
    defaultOptions.forEach(option => {
        if (Number.isInteger(option)) {
            options.push(option < flattenedOptions.length && option > 0 ? option : 0);
        }
        // we're a string, lets look it up based on the value/label and default to 0 if none
        const index = flattenedOptions === null || flattenedOptions === void 0 ? void 0 : flattenedOptions.findIndex(opt => (opt === null || opt === void 0 ? void 0 : opt.value) === option || (opt === null || opt === void 0 ? void 0 : opt.label) === option);
        options.push(index >= 0 ? index : 0);
    });
    return options;
};
const Select = ({ defaultOption = 0, disabled, error, helperText, label, name, options, onChange, value, }) => {
    var _a;
    // Flattens all options and sub grouped options for easier retrieval
    const flatOptions = flattenBaseSelectOptions(options);
    const defaultOptions = calculateDefaultOptions([defaultOption], flatOptions);
    const [selectedIdx, setSelectedIdx] = React.useState(defaultOptions.length > 0 ? defaultOptions[0] : 0);
    React.useEffect(() => {
        var _a;
        if (flatOptions.length !== 0) {
            onChange && onChange(((_a = flatOptions[selectedIdx]) === null || _a === void 0 ? void 0 : _a.value) || flatOptions[selectedIdx].label);
        }
    }, []);
    const updateSelectedOption = event => {
        const targetValue = event.target.value;
        // handle if selecting a header option
        if (!targetValue) {
            return;
        }
        setSelectedIdx(flatOptions.findIndex(opt => (opt === null || opt === void 0 ? void 0 : opt.value) === targetValue || (opt === null || opt === void 0 ? void 0 : opt.label) === targetValue));
        onChange && onChange(targetValue);
    };
    if (flatOptions.length === 0) {
        return null;
    }
    return (React.createElement(MuiFormControl, { id: name, key: name, disabled: disabled, error: error, fullWidth: true },
        label && React.createElement(StyledInputLabel, null, label),
        flatOptions.length && (React.createElement(StyledSelect, { id: `${name}-select`, value: value !== null && value !== void 0 ? value : (((_a = flatOptions[selectedIdx]) === null || _a === void 0 ? void 0 : _a.value) || flatOptions[selectedIdx].label), onChange: updateSelectedOption, label: label }, options === null || options === void 0 ? void 0 : options.map(option => renderSelectItems(option)))),
        helperText && (React.createElement(StyledFormHelperText, null,
            error && React.createElement(ErrorIcon, null),
            helperText))));
};
const MultiSelect = ({ defaultOptions = [], disabled, error, helperText, label, name, selectOptions, chipDisplay = false, onChange, }) => {
    // Flattens all options and sub grouped options for easier retrieval
    const flatOptions = flattenBaseSelectOptions(selectOptions);
    const [selectedOptions, setSelectedOptions] = React.useState(calculateDefaultOptions(defaultOptions, flatOptions));
    const selectedValues = () => selectedOptions.map(idx => flatOptions[idx].value || flatOptions[idx].label);
    React.useEffect(() => {
        if (flatOptions.length !== 0) {
            onChange && onChange(selectedValues());
        }
    }, [selectedOptions]);
    const updateSelectedOptions = event => {
        const { value } = event.target;
        // handle if selecting a header option
        if (!value) {
            return;
        }
        const findIndex = val => flatOptions.findIndex(opt => opt.value === val || opt.label === val);
        setSelectedOptions(value.map(val => findIndex(val)));
    };
    if (flatOptions.length === 0) {
        return null;
    }
    return (React.createElement(MuiFormControl, { id: name, key: name, disabled: disabled, error: error, fullWidth: true },
        label && React.createElement(StyledInputLabel, null, label),
        flatOptions.length && (React.createElement(StyledSelect, Object.assign({ multiple: true, id: `${name}-multi-select`, value: selectedValues(), onChange: updateSelectedOptions, label: label }, (chipDisplay && {
            renderValue: (selected) => (React.createElement("div", { style: { display: "flex", gap: "4px" } }, selected.sort().map(value => (React.createElement(Chip, { variant: "neutral", label: value, key: value, size: "small" }))))),
        })), selectOptions === null || selectOptions === void 0 ? void 0 : selectOptions.map(option => renderSelectItems(option)))),
        helperText && (React.createElement(StyledFormHelperText, null,
            error && React.createElement(ErrorIcon, null),
            helperText))));
};
export { Select, MultiSelect };
