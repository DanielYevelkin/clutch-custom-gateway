import * as _ from "lodash";
const getDisplayName = (workflow, route, delimiter = ":") => {
    let { displayName } = workflow;
    if (route.displayName) {
        displayName = `${displayName.toLowerCase() !== workflow.group.toLowerCase()
            ? `${displayName}${delimiter} `
            : ""}${route.displayName}`;
    }
    return displayName;
};
const workflowsByTrending = (workflows) => {
    const trending = [];
    const trendingIcons = {};
    workflows.forEach(workflow => {
        var _a;
        if (((_a = workflow === null || workflow === void 0 ? void 0 : workflow.icon) === null || _a === void 0 ? void 0 : _a.path) && !trendingIcons[workflow.group]) {
            trendingIcons[workflow.group] = workflow.icon.path;
        }
    });
    workflows.forEach(workflow => {
        workflow.routes.forEach(route => {
            var _a;
            if (route.trending) {
                trending.push({
                    displayName: getDisplayName(workflow, route),
                    group: workflow.group,
                    description: route.description,
                    path: `${workflow.path}/${route.path}`,
                    icon: (_a = trendingIcons[workflow.group]) !== null && _a !== void 0 ? _a : "",
                });
            }
        });
    });
    return trending;
};
const routesByGrouping = (workflows) => {
    const routes = {};
    workflows.forEach(workflow => {
        const category = workflow.group;
        if (routes[category] === undefined) {
            routes[category] = {
                workflows: [],
                icon: workflow.icon,
            };
        }
        routes[category].workflows = [
            ...routes[category].workflows,
            ...workflow.routes.map(route => {
                return {
                    displayName: getDisplayName(workflow, route, " -"),
                    path: `${workflow.path}/${route.path}`,
                    trending: route.trending || false,
                };
            }),
        ];
    });
    return routes;
};
/**
 * Will break a path down and iterate through given workflows to see if there is a matching path.
 */
const workflowByRoute = (workflows, route) => {
    const [baseRoute, ...subRoutes] = route.split("/").filter(Boolean);
    const subRoute = subRoutes.join("/");
    let returnFlow = null;
    const filtered = workflows.filter((workflow) => workflow.path === baseRoute);
    filtered.some((workflow) => {
        return workflow.routes.some((wroute) => {
            if (wroute.path === subRoute) {
                returnFlow = workflow;
            }
            return returnFlow !== null;
        });
    });
    return returnFlow;
};
const sortedGroupings = (workflows) => {
    return Object.keys(routesByGrouping(workflows)).sort();
};
const searchIndexes = (workflows) => {
    let indexOptions = [];
    workflows.forEach(workflow => {
        const category = workflow.group;
        indexOptions = [
            ...indexOptions,
            ...workflow.routes.map(route => {
                const label = route.displayName
                    ? `${workflow.displayName} - ${route.displayName}`
                    : workflow.displayName;
                return {
                    category,
                    label,
                    path: `${workflow.path}/${route.path}`,
                };
            }),
        ];
    });
    return indexOptions;
};
/** Filter out all of the workflows that are configured to be `hideNav: true`.
 * This prevents the workflows from being discoverable by the user from the UI where used.
 * Some example usages are in the search and drawer navigation components.
 *
 * The routes for all configured workflows will still be reachable
 * by manually providing the full path in the URI.
 */
const filterHiddenRoutes = (workflows) => _.cloneDeep(workflows).filter(workflow => {
    const publicRoutes = workflow.routes.filter(route => {
        return !((route === null || route === void 0 ? void 0 : route.hideNav) !== undefined ? route.hideNav : false);
    });
    workflow.routes = publicRoutes; /* eslint-disable-line no-param-reassign */
    return publicRoutes.length !== 0;
});
export { filterHiddenRoutes, routesByGrouping, searchIndexes, sortedGroupings, workflowByRoute, workflowsByTrending, };
