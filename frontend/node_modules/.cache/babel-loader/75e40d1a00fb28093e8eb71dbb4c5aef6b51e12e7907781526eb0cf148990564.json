{"ast":null,"code":"import _slicedToArray from \"/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport var useMaskedInput = function useMaskedInput(_ref) {\n  var _ref$acceptRegex = _ref.acceptRegex,\n    acceptRegex = _ref$acceptRegex === void 0 ? /[\\d]/gi : _ref$acceptRegex,\n    disabled = _ref.disabled,\n    disableMaskedInput = _ref.disableMaskedInput,\n    ignoreInvalidInputs = _ref.ignoreInvalidInputs,\n    inputFormat = _ref.inputFormat,\n    inputProps = _ref.inputProps,\n    label = _ref.label,\n    mask = _ref.mask,\n    onChange = _ref.onChange,\n    rawValue = _ref.rawValue,\n    readOnly = _ref.readOnly,\n    rifmFormatter = _ref.rifmFormatter,\n    TextFieldProps = _ref.TextFieldProps,\n    validationError = _ref.validationError;\n  var utils = useUtils();\n  var formatHelperText = utils.getFormatHelperText(inputFormat);\n  var _React$useMemo = React.useMemo(function () {\n      // formatting of dates is a quite slow thing, so do not make useless .format calls\n      if (disableMaskedInput) {\n        return {\n          shouldUseMaskedInput: false,\n          maskToUse: ''\n        };\n      }\n      var computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n      return {\n        shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n        maskToUse: computedMaskToUse\n      };\n    }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]),\n    shouldUseMaskedInput = _React$useMemo.shouldUseMaskedInput,\n    maskToUse = _React$useMemo.maskToUse;\n  var formatter = React.useMemo(function () {\n    return shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : function (st) {\n      return st;\n    };\n  }, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  var parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  var _React$useState = React.useState(parsedValue),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    innerInputValue = _React$useState2[0],\n    setInnerInputValue = _React$useState2[1]; // control the input text\n\n  var _React$useState3 = React.useState(getDisplayDate(utils, rawValue, inputFormat)),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    innerDisplayedInputValue = _React$useState4[0],\n    setInnerDisplayedInputValue = _React$useState4[1]; // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201\n\n  var prevRawValue = React.useRef();\n  var prevLocale = React.useRef(utils.locale);\n  var prevInputFormat = React.useRef(inputFormat);\n  React.useEffect(function () {\n    var rawValueHasChanged = rawValue !== prevRawValue.current;\n    var localeHasChanged = utils.locale !== prevLocale.current;\n    var inputFormatHasChanged = inputFormat !== prevInputFormat.current;\n    prevRawValue.current = rawValue;\n    prevLocale.current = utils.locale;\n    prevInputFormat.current = inputFormat;\n    if (!rawValueHasChanged && !localeHasChanged && !inputFormatHasChanged) {\n      return;\n    }\n    var newParsedValue = rawValue === null ? null : utils.date(rawValue);\n    var isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);\n    var innerEqualsParsed = innerInputValue === null && newParsedValue === null; // equal by being both null\n\n    if (innerInputValue !== null && newParsedValue !== null) {\n      var areEqual = utils.isEqual(innerInputValue, newParsedValue);\n      if (areEqual) {\n        innerEqualsParsed = true;\n      } else {\n        var diff = Math.abs(utils.getDiff(innerInputValue, newParsedValue)); // diff in ms\n\n        innerEqualsParsed = diff === 0 ? areEqual // if no diff, use equal to test the time-zone\n        : diff < 1000; // accept a difference bellow 1s\n      }\n    }\n\n    if (!localeHasChanged && !inputFormatHasChanged && (!isAcceptedValue || innerEqualsParsed)) {\n      return;\n    } // When dev set a new valid value, we trust them\n\n    var newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(newParsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }, [utils, rawValue, inputFormat, innerInputValue]);\n  var handleChange = function handleChange(text) {\n    var finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    var date = finalString === null ? null : utils.parse(finalString, inputFormat);\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n  var rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  var inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: function onChange(event) {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label: label,\n    disabled: disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled: disabled,\n      placeholder: formatHelperText,\n      readOnly: readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};","map":{"version":3,"names":["_extends","React","useRifm","useUtils","maskedDateFormatter","getDisplayDate","checkMaskIsValidForCurrentFormat","getMaskFromCurrentFormat","useMaskedInput","_ref","_ref$acceptRegex","acceptRegex","disabled","disableMaskedInput","ignoreInvalidInputs","inputFormat","inputProps","label","mask","onChange","rawValue","readOnly","rifmFormatter","TextFieldProps","validationError","utils","formatHelperText","getFormatHelperText","_React$useMemo","useMemo","shouldUseMaskedInput","maskToUse","computedMaskToUse","formatter","st","parsedValue","date","_React$useState","useState","_React$useState2","_slicedToArray","innerInputValue","setInnerInputValue","_React$useState3","_React$useState4","innerDisplayedInputValue","setInnerDisplayedInputValue","prevRawValue","useRef","prevLocale","locale","prevInputFormat","useEffect","rawValueHasChanged","current","localeHasChanged","inputFormatHasChanged","newParsedValue","isAcceptedValue","isValid","innerEqualsParsed","areEqual","isEqual","diff","Math","abs","getDiff","newDisplayDate","handleChange","text","finalString","parse","undefined","rifmProps","value","format","inputStateArgs","event","currentTarget","error","placeholder","type"],"sources":["/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@mui/x-date-pickers/internals/hooks/useMaskedInput.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useRifm } from 'rifm';\nimport { useUtils } from './useUtils';\nimport { maskedDateFormatter, getDisplayDate, checkMaskIsValidForCurrentFormat, getMaskFromCurrentFormat } from '../utils/text-field-helper';\nexport const useMaskedInput = ({\n  acceptRegex = /[\\d]/gi,\n  disabled,\n  disableMaskedInput,\n  ignoreInvalidInputs,\n  inputFormat,\n  inputProps,\n  label,\n  mask,\n  onChange,\n  rawValue,\n  readOnly,\n  rifmFormatter,\n  TextFieldProps,\n  validationError\n}) => {\n  const utils = useUtils();\n  const formatHelperText = utils.getFormatHelperText(inputFormat);\n  const {\n    shouldUseMaskedInput,\n    maskToUse\n  } = React.useMemo(() => {\n    // formatting of dates is a quite slow thing, so do not make useless .format calls\n    if (disableMaskedInput) {\n      return {\n        shouldUseMaskedInput: false,\n        maskToUse: ''\n      };\n    }\n\n    const computedMaskToUse = getMaskFromCurrentFormat(mask, inputFormat, acceptRegex, utils);\n    return {\n      shouldUseMaskedInput: checkMaskIsValidForCurrentFormat(computedMaskToUse, inputFormat, acceptRegex, utils),\n      maskToUse: computedMaskToUse\n    };\n  }, [acceptRegex, disableMaskedInput, inputFormat, mask, utils]);\n  const formatter = React.useMemo(() => shouldUseMaskedInput && maskToUse ? maskedDateFormatter(maskToUse, acceptRegex) : st => st, [acceptRegex, maskToUse, shouldUseMaskedInput]); // TODO: Implement with controlled vs uncontrolled `rawValue`\n\n  const parsedValue = rawValue === null ? null : utils.date(rawValue); // Track the value of the input\n\n  const [innerInputValue, setInnerInputValue] = React.useState(parsedValue); // control the input text\n\n  const [innerDisplayedInputValue, setInnerDisplayedInputValue] = React.useState(getDisplayDate(utils, rawValue, inputFormat)); // Inspired from autocomplete: https://github.com/mui/material-ui/blob/2c89d036dc2e16f100528f161600dffc83241768/packages/mui-base/src/AutocompleteUnstyled/useAutocomplete.js#L185:L201\n\n  const prevRawValue = React.useRef();\n  const prevLocale = React.useRef(utils.locale);\n  const prevInputFormat = React.useRef(inputFormat);\n  React.useEffect(() => {\n    const rawValueHasChanged = rawValue !== prevRawValue.current;\n    const localeHasChanged = utils.locale !== prevLocale.current;\n    const inputFormatHasChanged = inputFormat !== prevInputFormat.current;\n    prevRawValue.current = rawValue;\n    prevLocale.current = utils.locale;\n    prevInputFormat.current = inputFormat;\n\n    if (!rawValueHasChanged && !localeHasChanged && !inputFormatHasChanged) {\n      return;\n    }\n\n    const newParsedValue = rawValue === null ? null : utils.date(rawValue);\n    const isAcceptedValue = rawValue === null || utils.isValid(newParsedValue);\n    let innerEqualsParsed = innerInputValue === null && newParsedValue === null; // equal by being both null\n\n    if (innerInputValue !== null && newParsedValue !== null) {\n      const areEqual = utils.isEqual(innerInputValue, newParsedValue);\n\n      if (areEqual) {\n        innerEqualsParsed = true;\n      } else {\n        const diff = Math.abs(utils.getDiff(innerInputValue, newParsedValue)); // diff in ms\n\n        innerEqualsParsed = diff === 0 ? areEqual // if no diff, use equal to test the time-zone\n        : diff < 1000; // accept a difference bellow 1s\n      }\n    }\n\n    if (!localeHasChanged && !inputFormatHasChanged && (!isAcceptedValue || innerEqualsParsed)) {\n      return;\n    } // When dev set a new valid value, we trust them\n\n\n    const newDisplayDate = getDisplayDate(utils, rawValue, inputFormat);\n    setInnerInputValue(newParsedValue);\n    setInnerDisplayedInputValue(newDisplayDate);\n  }, [utils, rawValue, inputFormat, innerInputValue]);\n\n  const handleChange = text => {\n    const finalString = text === '' || text === mask ? '' : text;\n    setInnerDisplayedInputValue(finalString);\n    const date = finalString === null ? null : utils.parse(finalString, inputFormat);\n\n    if (ignoreInvalidInputs && !utils.isValid(date)) {\n      return;\n    }\n\n    setInnerInputValue(date);\n    onChange(date, finalString || undefined);\n  };\n\n  const rifmProps = useRifm({\n    value: innerDisplayedInputValue,\n    onChange: handleChange,\n    format: rifmFormatter || formatter\n  });\n  const inputStateArgs = shouldUseMaskedInput ? rifmProps : {\n    value: innerDisplayedInputValue,\n    onChange: event => {\n      handleChange(event.currentTarget.value);\n    }\n  };\n  return _extends({\n    label,\n    disabled,\n    error: validationError,\n    inputProps: _extends({}, inputStateArgs, {\n      disabled,\n      placeholder: formatHelperText,\n      readOnly,\n      type: shouldUseMaskedInput ? 'tel' : 'text'\n    }, inputProps)\n  }, TextFieldProps);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}