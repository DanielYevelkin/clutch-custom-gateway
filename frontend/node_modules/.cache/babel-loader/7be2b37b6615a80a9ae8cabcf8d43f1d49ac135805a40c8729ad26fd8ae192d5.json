{"ast":null,"code":"import _slicedToArray from \"/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from \"react\";\nimport { CartesianGrid, Legend, Line, LineChart, ReferenceLine, ResponsiveContainer, Tooltip, XAxis, YAxis } from \"recharts\";\nimport { calculateDomainEdges, calculateTicks, localTimeFormatter } from \"./helpers\";\n/*\n  For the lines, use the `dataKey` property to denote which data points belong to that line. Make sure that\n  all the dataKeys match appropriately (the XAxis datakey should correspond to the data that is graphed along\n  the XAxis, and same for Y. Note that we currently set the XAxis to be a time scale, hence the name\n  Timeseries Chart).\n  \n  The data will be internally sorted by the XAxis dataKey when using single line mode. When having multiple lines\n  (singleLineMode is false) then the user is responsible for sorting and grouping the data appropriately.\n  If they do not sort and group it, there can be discontinuities in the lines. Also, when using multiple lines,\n  the user should pass the yAxisDataKey as the biggest ranged y axis datakey in the data, otherwise data will get chopped off.\n\n  The timestamps are interpreted as unix milliseconds.\n*/\n// TODO(smonero): add tests for this component\nvar TimeseriesChart = function TimeseriesChart(_ref) {\n  var data = _ref.data,\n    _ref$xAxisDataKey = _ref.xAxisDataKey,\n    xAxisDataKey = _ref$xAxisDataKey === void 0 ? \"timestamp\" : _ref$xAxisDataKey,\n    _ref$yAxisDataKey = _ref.yAxisDataKey,\n    yAxisDataKey = _ref$yAxisDataKey === void 0 ? \"value\" : _ref$yAxisDataKey,\n    lines = _ref.lines,\n    refLines = _ref.refLines,\n    _ref$singleLineMode = _ref.singleLineMode,\n    singleLineMode = _ref$singleLineMode === void 0 ? true : _ref$singleLineMode,\n    _ref$drawDots = _ref.drawDots,\n    drawDots = _ref$drawDots === void 0 ? true : _ref$drawDots,\n    _ref$legend = _ref.legend,\n    legend = _ref$legend === void 0 ? true : _ref$legend,\n    _ref$grid = _ref.grid,\n    grid = _ref$grid === void 0 ? true : _ref$grid,\n    _ref$tickFormatterFun = _ref.tickFormatterFunc,\n    tickFormatterFunc = _ref$tickFormatterFun === void 0 ? localTimeFormatter : _ref$tickFormatterFun,\n    _ref$xDomainSpread = _ref.xDomainSpread,\n    xDomainSpread = _ref$xDomainSpread === void 0 ? 0.2 : _ref$xDomainSpread,\n    _ref$yDomainSpread = _ref.yDomainSpread,\n    yDomainSpread = _ref$yDomainSpread === void 0 ? 0.2 : _ref$yDomainSpread,\n    _ref$connectNulls = _ref.connectNulls,\n    connectNulls = _ref$connectNulls === void 0 ? false : _ref$connectNulls,\n    _ref$regularIntervalT = _ref.regularIntervalTicks,\n    regularIntervalTicks = _ref$regularIntervalT === void 0 ? false : _ref$regularIntervalT,\n    _ref$tooltipFormatter = _ref.tooltipFormatterFunc,\n    tooltipFormatterFunc = _ref$tooltipFormatter === void 0 ? null : _ref$tooltipFormatter,\n    _ref$stylingProps = _ref.stylingProps,\n    stylingProps = _ref$stylingProps === void 0 ? {} : _ref$stylingProps;\n  if (singleLineMode) {\n    data.sort(function (a, b) {\n      return a[xAxisDataKey] - b[xAxisDataKey];\n    });\n  }\n  var _calculateDomainEdges = calculateDomainEdges(data, yAxisDataKey, yDomainSpread !== null && yDomainSpread !== void 0 ? yDomainSpread : 0),\n    _calculateDomainEdges2 = _slicedToArray(_calculateDomainEdges, 2),\n    yAxisDomainMin = _calculateDomainEdges2[0],\n    yAxisDomainMax = _calculateDomainEdges2[1];\n  var _calculateDomainEdges3 = calculateDomainEdges(data, xAxisDataKey, xDomainSpread !== null && xDomainSpread !== void 0 ? xDomainSpread : 0),\n    _calculateDomainEdges4 = _slicedToArray(_calculateDomainEdges3, 2),\n    xAxisDomainMin = _calculateDomainEdges4[0],\n    xAxisDomainMax = _calculateDomainEdges4[1];\n  // In the spirit of making a friendly UX, there is an option to generate evenly spaced, round-timestamped, ticks.\n  // Depending on the distance between the max and min timestamps, we calculate a set of ticks at certain intervals\n  // (I.e. if there are several minutes, we might use minute intervals, whereas if there are only a few minutes range,\n  // we would use 30 second intervals, and if the range consists of hours, we might use 15 or 30 minute intervals)\n  var ticks = [];\n  if (regularIntervalTicks) {\n    ticks = calculateTicks(data, xAxisDataKey);\n  }\n  return React.createElement(ResponsiveContainer, {\n    width: \"100%\",\n    height: \"100%\"\n  }, React.createElement(LineChart, {\n    data: data\n  }, grid ? React.createElement(CartesianGrid, {\n    stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridStroke,\n    fill: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridBackgroundColor\n  }) : null, React.createElement(XAxis, {\n    dataKey: xAxisDataKey,\n    type: \"number\",\n    domain: [xAxisDomainMin, xAxisDomainMax],\n    tickFormatter: tickFormatterFunc,\n    allowDataOverflow: true,\n    ticks: regularIntervalTicks ? ticks : null,\n    stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.xAxisStroke\n  }),\n  // Note that if a number is NaN Recharts will default the domain to `auto`\n  singleLineMode ? React.createElement(YAxis, {\n    dataKey: yAxisDataKey,\n    domain: [yAxisDomainMin, yAxisDomainMax],\n    stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.yAxisStroke,\n    type: \"number\"\n  }) : React.createElement(YAxis, {\n    type: \"number\",\n    domain: [yAxisDomainMin, yAxisDomainMax],\n    stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.yAxisStroke\n  }), React.createElement(Tooltip, {\n    formatter: tooltipFormatterFunc\n  }), legend ? React.createElement(Legend, null) : null, lines ? lines.map(function (line, index) {\n    var _a;\n    return React.createElement(Line, {\n      key: index.toString() + line.dataKey,\n      type: \"linear\",\n      dataKey: line.dataKey,\n      stroke: line.color,\n      animationDuration: (_a = line.animationDuration) !== null && _a !== void 0 ? _a : 0,\n      dot: drawDots,\n      connectNulls: connectNulls\n    });\n  }) : null, refLines && refLines.map(function (refLine, index) {\n    var props = {};\n    props[refLine.axis] = refLine.coordinate;\n    return React.createElement(ReferenceLine, Object.assign({\n      key: index.toString() + refLine.coordinate.toString(),\n      label: refLine.label,\n      stroke: refLine.color,\n      strokeDasharray: refLine.axis === \"x\" ? \"3 3\" : \"4 4\"\n    }, props));\n  })));\n};\nexport default TimeseriesChart;","map":{"version":3,"names":["React","CartesianGrid","Legend","Line","LineChart","ReferenceLine","ResponsiveContainer","Tooltip","XAxis","YAxis","calculateDomainEdges","calculateTicks","localTimeFormatter","TimeseriesChart","_ref","data","_ref$xAxisDataKey","xAxisDataKey","_ref$yAxisDataKey","yAxisDataKey","lines","refLines","_ref$singleLineMode","singleLineMode","_ref$drawDots","drawDots","_ref$legend","legend","_ref$grid","grid","_ref$tickFormatterFun","tickFormatterFunc","_ref$xDomainSpread","xDomainSpread","_ref$yDomainSpread","yDomainSpread","_ref$connectNulls","connectNulls","_ref$regularIntervalT","regularIntervalTicks","_ref$tooltipFormatter","tooltipFormatterFunc","_ref$stylingProps","stylingProps","sort","a","b","_calculateDomainEdges","_calculateDomainEdges2","_slicedToArray","yAxisDomainMin","yAxisDomainMax","_calculateDomainEdges3","_calculateDomainEdges4","xAxisDomainMin","xAxisDomainMax","ticks","createElement","width","height","stroke","gridStroke","fill","gridBackgroundColor","dataKey","type","domain","tickFormatter","allowDataOverflow","xAxisStroke","yAxisStroke","formatter","map","line","index","_a","key","toString","color","animationDuration","dot","refLine","props","axis","coordinate","Object","assign","label","strokeDasharray"],"sources":["/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@clutch-sh/core/dist/Charts/timeseries.js"],"sourcesContent":["import React from \"react\";\nimport { CartesianGrid, Legend, Line, LineChart, ReferenceLine, ResponsiveContainer, Tooltip, XAxis, YAxis, } from \"recharts\";\nimport { calculateDomainEdges, calculateTicks, localTimeFormatter } from \"./helpers\";\n/*\n  For the lines, use the `dataKey` property to denote which data points belong to that line. Make sure that\n  all the dataKeys match appropriately (the XAxis datakey should correspond to the data that is graphed along\n  the XAxis, and same for Y. Note that we currently set the XAxis to be a time scale, hence the name\n  Timeseries Chart).\n  \n  The data will be internally sorted by the XAxis dataKey when using single line mode. When having multiple lines\n  (singleLineMode is false) then the user is responsible for sorting and grouping the data appropriately.\n  If they do not sort and group it, there can be discontinuities in the lines. Also, when using multiple lines,\n  the user should pass the yAxisDataKey as the biggest ranged y axis datakey in the data, otherwise data will get chopped off.\n\n  The timestamps are interpreted as unix milliseconds.\n*/\n// TODO(smonero): add tests for this component\nconst TimeseriesChart = ({ data, xAxisDataKey = \"timestamp\", yAxisDataKey = \"value\", lines, refLines, singleLineMode = true, drawDots = true, legend = true, grid = true, tickFormatterFunc = localTimeFormatter, xDomainSpread = 0.2, yDomainSpread = 0.2, connectNulls = false, regularIntervalTicks = false, tooltipFormatterFunc = null, stylingProps = {}, }) => {\n    if (singleLineMode) {\n        data.sort((a, b) => a[xAxisDataKey] - b[xAxisDataKey]);\n    }\n    const [yAxisDomainMin, yAxisDomainMax] = calculateDomainEdges(data, yAxisDataKey, yDomainSpread !== null && yDomainSpread !== void 0 ? yDomainSpread : 0);\n    const [xAxisDomainMin, xAxisDomainMax] = calculateDomainEdges(data, xAxisDataKey, xDomainSpread !== null && xDomainSpread !== void 0 ? xDomainSpread : 0);\n    // In the spirit of making a friendly UX, there is an option to generate evenly spaced, round-timestamped, ticks.\n    // Depending on the distance between the max and min timestamps, we calculate a set of ticks at certain intervals\n    // (I.e. if there are several minutes, we might use minute intervals, whereas if there are only a few minutes range,\n    // we would use 30 second intervals, and if the range consists of hours, we might use 15 or 30 minute intervals)\n    let ticks = [];\n    if (regularIntervalTicks) {\n        ticks = calculateTicks(data, xAxisDataKey);\n    }\n    return (React.createElement(ResponsiveContainer, { width: \"100%\", height: \"100%\" },\n        React.createElement(LineChart, { data: data },\n            grid ? (React.createElement(CartesianGrid, { stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridStroke, fill: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridBackgroundColor })) : null,\n            React.createElement(XAxis, { dataKey: xAxisDataKey, type: \"number\", domain: [xAxisDomainMin, xAxisDomainMax], tickFormatter: tickFormatterFunc, allowDataOverflow: true, ticks: regularIntervalTicks ? ticks : null, stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.xAxisStroke }),\n            // Note that if a number is NaN Recharts will default the domain to `auto`\n            singleLineMode ? (React.createElement(YAxis, { dataKey: yAxisDataKey, domain: [yAxisDomainMin, yAxisDomainMax], stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.yAxisStroke, type: \"number\" })) : (React.createElement(YAxis, { type: \"number\", domain: [yAxisDomainMin, yAxisDomainMax], stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.yAxisStroke })),\n            React.createElement(Tooltip, { formatter: tooltipFormatterFunc }),\n            legend ? React.createElement(Legend, null) : null,\n            lines\n                ? lines.map((line, index) => {\n                    var _a;\n                    return (React.createElement(Line, { key: index.toString() + line.dataKey, type: \"linear\", dataKey: line.dataKey, stroke: line.color, animationDuration: (_a = line.animationDuration) !== null && _a !== void 0 ? _a : 0, dot: drawDots, connectNulls: connectNulls }));\n                })\n                : null,\n            refLines &&\n                refLines.map((refLine, index) => {\n                    const props = {};\n                    props[refLine.axis] = refLine.coordinate;\n                    return (React.createElement(ReferenceLine, Object.assign({ key: index.toString() + refLine.coordinate.toString(), label: refLine.label, stroke: refLine.color, strokeDasharray: refLine.axis === \"x\" ? \"3 3\" : \"4 4\" }, props)));\n                }))));\n};\nexport default TimeseriesChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}