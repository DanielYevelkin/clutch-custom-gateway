{"ast":null,"code":"import _toConsumableArray from \"/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nexport var localTimeFormatter = function localTimeFormatter(timestamp) {\n  return new Date(timestamp).toLocaleTimeString();\n};\nexport var isoTimeFormatter = function isoTimeFormatter(timestamp) {\n  return new Date(timestamp).toISOString();\n};\nexport var dateTimeFormatter = function dateTimeFormatter(timestamp) {\n  return new Date(timestamp).toDateString();\n};\nexport var getMinAndMaxOfRangeUsingKey = function getMinAndMaxOfRangeUsingKey(data, key) {\n  if (!data) {\n    return {\n      min: null,\n      max: null\n    };\n  }\n  var filtered = data.filter(function (d) {\n    return d[key];\n  }).map(function (d) {\n    return d[key];\n  });\n  return {\n    min: Math.min.apply(Math, _toConsumableArray(filtered)),\n    max: Math.max.apply(Math, _toConsumableArray(filtered))\n  };\n};\n// Edge ratio refers to the multiplicative part of the amount that will be added to the max,\n// and subtracted from the min.\nexport var calculateDomainEdges = function calculateDomainEdges(data, dataKey, edgeRatio) {\n  // Get the max and min of the domain, then calculate a certain amount`out from each edge.\n  var _getMinAndMaxOfRangeU = getMinAndMaxOfRangeUsingKey(data, dataKey),\n    min = _getMinAndMaxOfRangeU.min,\n    max = _getMinAndMaxOfRangeU.max;\n  if (edgeRatio <= 0 || !Number.isFinite(min) || !Number.isFinite(max)) {\n    return [min, max];\n  }\n  if (max === min) {\n    var _minEdge = min - min * edgeRatio;\n    var _maxEdge = max + max * edgeRatio;\n    return [_minEdge, _maxEdge];\n  }\n  var edgeVal = (max - min) * edgeRatio;\n  var minEdge = min - edgeVal;\n  var maxEdge = max + edgeVal;\n  return [minEdge, maxEdge];\n};\nvar oneSec = 1000; // in ms\nvar fifteenSeconds = 15 * oneSec;\nvar oneMin = 60 * oneSec;\nvar threeMins = 3 * oneMin;\nvar fiveMins = 5 * oneMin;\nvar tenMins = 10 * oneMin;\nvar fifteenMins = 15 * oneMin;\nvar halfHour = 30 * oneMin;\nvar oneHour = 60 * oneMin;\nvar threeHours = 3 * oneHour;\nvar sixHours = 6 * oneHour;\nvar twelveHours = 12 * oneHour;\nvar dayDuration = 24 * oneHour;\nvar weekDuration = 7 * dayDuration;\nvar monthDuration = 30 * dayDuration;\nvar yearDuration = 365 * dayDuration;\nvar zoomLevelsToIntervals = {\n  oneMin: fifteenSeconds,\n  threeMins: fifteenSeconds,\n  fiveMins: oneMin,\n  tenMins: oneMin,\n  fifteenMins: threeMins,\n  halfHour: fiveMins,\n  oneHour: tenMins,\n  threeHours: halfHour,\n  sixHours: oneHour,\n  twelveHours: threeHours,\n  day: sixHours,\n  week: dayDuration,\n  month: weekDuration,\n  year: monthDuration\n};\n// This function allows us to get the starting point for our ticks, as well as the space between ticks.\n// We have presets according to the span between the min and max timestamps.\nexport var getLeftSideAndIntervalForTicks = function getLeftSideAndIntervalForTicks(min, max) {\n  if (!Number.isFinite(min) || !Number.isFinite(max) || min > max) {\n    return {\n      leftSide: null,\n      interval: null\n    };\n  }\n  var diff = max - min;\n  var zoomLevel = \"\";\n  switch (true) {\n    case diff < oneMin:\n      zoomLevel = \"oneMin\";\n      break;\n    case diff < fiveMins:\n      zoomLevel = \"fiveMins\";\n      break;\n    case diff < tenMins:\n      zoomLevel = \"tenMins\";\n      break;\n    case diff < fifteenMins:\n      zoomLevel = \"fifteenMins\";\n      break;\n    case diff < halfHour:\n      zoomLevel = \"halfHour\";\n      break;\n    case diff < oneHour:\n      zoomLevel = \"oneHour\";\n      break;\n    case diff < threeHours:\n      zoomLevel = \"threeHours\";\n      break;\n    case diff < sixHours:\n      zoomLevel = \"sixHours\";\n      break;\n    case diff < twelveHours:\n      zoomLevel = \"twelveHours\";\n      break;\n    case diff < dayDuration:\n      zoomLevel = \"day\";\n      break;\n    case diff < weekDuration:\n      zoomLevel = \"week\";\n      break;\n    case diff < monthDuration:\n      zoomLevel = \"month\";\n      break;\n    case diff < yearDuration:\n      zoomLevel = \"month\";\n      break;\n    default:\n      zoomLevel = \"year\";\n  }\n  var interval = zoomLevelsToIntervals[zoomLevel];\n  var leftSide = min - min % interval;\n  return {\n    leftSide: leftSide,\n    interval: interval\n  };\n};\n// Based off the min and max, calculate where the regularly spaced tick marks should be.\n// We modulo down to the closest similar timestamp based off the difference between the min and max.\n// We then iterate from that value to the max pushing timestamps to our array when we land on an\n// appropriate interval.\nexport var calculateTicks = function calculateTicks(data, dataKey) {\n  var _getMinAndMaxOfRangeU2 = getMinAndMaxOfRangeUsingKey(data, dataKey),\n    min = _getMinAndMaxOfRangeU2.min,\n    max = _getMinAndMaxOfRangeU2.max;\n  var _getLeftSideAndInterv = getLeftSideAndIntervalForTicks(min, max),\n    leftSide = _getLeftSideAndInterv.leftSide,\n    interval = _getLeftSideAndInterv.interval;\n  var ticks = [];\n  if (!Number.isFinite(leftSide) || !Number.isFinite(interval) || !Number.isFinite(min) || !Number.isFinite(max)) {\n    return ticks;\n  }\n  for (var i = leftSide; i <= max; i += interval) {\n    ticks.push(i);\n  }\n  return ticks;\n};","map":{"version":3,"names":["localTimeFormatter","timestamp","Date","toLocaleTimeString","isoTimeFormatter","toISOString","dateTimeFormatter","toDateString","getMinAndMaxOfRangeUsingKey","data","key","min","max","filtered","filter","d","map","Math","apply","_toConsumableArray","calculateDomainEdges","dataKey","edgeRatio","_getMinAndMaxOfRangeU","Number","isFinite","minEdge","maxEdge","edgeVal","oneSec","fifteenSeconds","oneMin","threeMins","fiveMins","tenMins","fifteenMins","halfHour","oneHour","threeHours","sixHours","twelveHours","dayDuration","weekDuration","monthDuration","yearDuration","zoomLevelsToIntervals","day","week","month","year","getLeftSideAndIntervalForTicks","leftSide","interval","diff","zoomLevel","calculateTicks","_getMinAndMaxOfRangeU2","_getLeftSideAndInterv","ticks","i","push"],"sources":["/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@clutch-sh/core/dist/Charts/helpers.js"],"sourcesContent":["export const localTimeFormatter = (timestamp) => {\n    return new Date(timestamp).toLocaleTimeString();\n};\nexport const isoTimeFormatter = (timestamp) => {\n    return new Date(timestamp).toISOString();\n};\nexport const dateTimeFormatter = (timestamp) => {\n    return new Date(timestamp).toDateString();\n};\nexport const getMinAndMaxOfRangeUsingKey = (data, key) => {\n    if (!data) {\n        return {\n            min: null,\n            max: null,\n        };\n    }\n    const filtered = data.filter(d => d[key]).map(d => d[key]);\n    return { min: Math.min(...filtered), max: Math.max(...filtered) };\n};\n// Edge ratio refers to the multiplicative part of the amount that will be added to the max,\n// and subtracted from the min.\nexport const calculateDomainEdges = (data, dataKey, edgeRatio) => {\n    // Get the max and min of the domain, then calculate a certain amount`out from each edge.\n    const { min, max } = getMinAndMaxOfRangeUsingKey(data, dataKey);\n    if (edgeRatio <= 0 || !Number.isFinite(min) || !Number.isFinite(max)) {\n        return [min, max];\n    }\n    if (max === min) {\n        const minEdge = min - min * edgeRatio;\n        const maxEdge = max + max * edgeRatio;\n        return [minEdge, maxEdge];\n    }\n    const edgeVal = (max - min) * edgeRatio;\n    const minEdge = min - edgeVal;\n    const maxEdge = max + edgeVal;\n    return [minEdge, maxEdge];\n};\nconst oneSec = 1000; // in ms\nconst fifteenSeconds = 15 * oneSec;\nconst oneMin = 60 * oneSec;\nconst threeMins = 3 * oneMin;\nconst fiveMins = 5 * oneMin;\nconst tenMins = 10 * oneMin;\nconst fifteenMins = 15 * oneMin;\nconst halfHour = 30 * oneMin;\nconst oneHour = 60 * oneMin;\nconst threeHours = 3 * oneHour;\nconst sixHours = 6 * oneHour;\nconst twelveHours = 12 * oneHour;\nconst dayDuration = 24 * oneHour;\nconst weekDuration = 7 * dayDuration;\nconst monthDuration = 30 * dayDuration;\nconst yearDuration = 365 * dayDuration;\nconst zoomLevelsToIntervals = {\n    oneMin: fifteenSeconds,\n    threeMins: fifteenSeconds,\n    fiveMins: oneMin,\n    tenMins: oneMin,\n    fifteenMins: threeMins,\n    halfHour: fiveMins,\n    oneHour: tenMins,\n    threeHours: halfHour,\n    sixHours: oneHour,\n    twelveHours: threeHours,\n    day: sixHours,\n    week: dayDuration,\n    month: weekDuration,\n    year: monthDuration,\n};\n// This function allows us to get the starting point for our ticks, as well as the space between ticks.\n// We have presets according to the span between the min and max timestamps.\nexport const getLeftSideAndIntervalForTicks = (min, max) => {\n    if (!Number.isFinite(min) || !Number.isFinite(max) || min > max) {\n        return {\n            leftSide: null,\n            interval: null,\n        };\n    }\n    const diff = max - min;\n    let zoomLevel = \"\";\n    switch (true) {\n        case diff < oneMin:\n            zoomLevel = \"oneMin\";\n            break;\n        case diff < fiveMins:\n            zoomLevel = \"fiveMins\";\n            break;\n        case diff < tenMins:\n            zoomLevel = \"tenMins\";\n            break;\n        case diff < fifteenMins:\n            zoomLevel = \"fifteenMins\";\n            break;\n        case diff < halfHour:\n            zoomLevel = \"halfHour\";\n            break;\n        case diff < oneHour:\n            zoomLevel = \"oneHour\";\n            break;\n        case diff < threeHours:\n            zoomLevel = \"threeHours\";\n            break;\n        case diff < sixHours:\n            zoomLevel = \"sixHours\";\n            break;\n        case diff < twelveHours:\n            zoomLevel = \"twelveHours\";\n            break;\n        case diff < dayDuration:\n            zoomLevel = \"day\";\n            break;\n        case diff < weekDuration:\n            zoomLevel = \"week\";\n            break;\n        case diff < monthDuration:\n            zoomLevel = \"month\";\n            break;\n        case diff < yearDuration:\n            zoomLevel = \"month\";\n            break;\n        default:\n            zoomLevel = \"year\";\n    }\n    const interval = zoomLevelsToIntervals[zoomLevel];\n    const leftSide = min - (min % interval);\n    return { leftSide, interval };\n};\n// Based off the min and max, calculate where the regularly spaced tick marks should be.\n// We modulo down to the closest similar timestamp based off the difference between the min and max.\n// We then iterate from that value to the max pushing timestamps to our array when we land on an\n// appropriate interval.\nexport const calculateTicks = (data, dataKey) => {\n    const { min, max } = getMinAndMaxOfRangeUsingKey(data, dataKey);\n    const { leftSide, interval } = getLeftSideAndIntervalForTicks(min, max);\n    const ticks = [];\n    if (!Number.isFinite(leftSide) ||\n        !Number.isFinite(interval) ||\n        !Number.isFinite(min) ||\n        !Number.isFinite(max)) {\n        return ticks;\n    }\n    for (let i = leftSide; i <= max; i += interval) {\n        ticks.push(i);\n    }\n    return ticks;\n};\n"],"mappings":";AAAA,OAAO,IAAMA,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIC,SAAS,EAAK;EAC7C,OAAO,IAAIC,IAAI,CAACD,SAAS,CAAC,CAACE,kBAAkB,CAAC,CAAC;AACnD,CAAC;AACD,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIH,SAAS,EAAK;EAC3C,OAAO,IAAIC,IAAI,CAACD,SAAS,CAAC,CAACI,WAAW,CAAC,CAAC;AAC5C,CAAC;AACD,OAAO,IAAMC,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIL,SAAS,EAAK;EAC5C,OAAO,IAAIC,IAAI,CAACD,SAAS,CAAC,CAACM,YAAY,CAAC,CAAC;AAC7C,CAAC;AACD,OAAO,IAAMC,2BAA2B,GAAG,SAA9BA,2BAA2BA,CAAIC,IAAI,EAAEC,GAAG,EAAK;EACtD,IAAI,CAACD,IAAI,EAAE;IACP,OAAO;MACHE,GAAG,EAAE,IAAI;MACTC,GAAG,EAAE;IACT,CAAC;EACL;EACA,IAAMC,QAAQ,GAAGJ,IAAI,CAACK,MAAM,CAAC,UAAAC,CAAC;IAAA,OAAIA,CAAC,CAACL,GAAG,CAAC;EAAA,EAAC,CAACM,GAAG,CAAC,UAAAD,CAAC;IAAA,OAAIA,CAAC,CAACL,GAAG,CAAC;EAAA,EAAC;EAC1D,OAAO;IAAEC,GAAG,EAAEM,IAAI,CAACN,GAAG,CAAAO,KAAA,CAARD,IAAI,EAAAE,kBAAA,CAAQN,QAAQ,EAAC;IAAED,GAAG,EAAEK,IAAI,CAACL,GAAG,CAAAM,KAAA,CAARD,IAAI,EAAAE,kBAAA,CAAQN,QAAQ;EAAE,CAAC;AACrE,CAAC;AACD;AACA;AACA,OAAO,IAAMO,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIX,IAAI,EAAEY,OAAO,EAAEC,SAAS,EAAK;EAC9D;EACA,IAAAC,qBAAA,GAAqBf,2BAA2B,CAACC,IAAI,EAAEY,OAAO,CAAC;IAAvDV,GAAG,GAAAY,qBAAA,CAAHZ,GAAG;IAAEC,GAAG,GAAAW,qBAAA,CAAHX,GAAG;EAChB,IAAIU,SAAS,IAAI,CAAC,IAAI,CAACE,MAAM,CAACC,QAAQ,CAACd,GAAG,CAAC,IAAI,CAACa,MAAM,CAACC,QAAQ,CAACb,GAAG,CAAC,EAAE;IAClE,OAAO,CAACD,GAAG,EAAEC,GAAG,CAAC;EACrB;EACA,IAAIA,GAAG,KAAKD,GAAG,EAAE;IACb,IAAMe,QAAO,GAAGf,GAAG,GAAGA,GAAG,GAAGW,SAAS;IACrC,IAAMK,QAAO,GAAGf,GAAG,GAAGA,GAAG,GAAGU,SAAS;IACrC,OAAO,CAACI,QAAO,EAAEC,QAAO,CAAC;EAC7B;EACA,IAAMC,OAAO,GAAG,CAAChB,GAAG,GAAGD,GAAG,IAAIW,SAAS;EACvC,IAAMI,OAAO,GAAGf,GAAG,GAAGiB,OAAO;EAC7B,IAAMD,OAAO,GAAGf,GAAG,GAAGgB,OAAO;EAC7B,OAAO,CAACF,OAAO,EAAEC,OAAO,CAAC;AAC7B,CAAC;AACD,IAAME,MAAM,GAAG,IAAI,CAAC,CAAC;AACrB,IAAMC,cAAc,GAAG,EAAE,GAAGD,MAAM;AAClC,IAAME,MAAM,GAAG,EAAE,GAAGF,MAAM;AAC1B,IAAMG,SAAS,GAAG,CAAC,GAAGD,MAAM;AAC5B,IAAME,QAAQ,GAAG,CAAC,GAAGF,MAAM;AAC3B,IAAMG,OAAO,GAAG,EAAE,GAAGH,MAAM;AAC3B,IAAMI,WAAW,GAAG,EAAE,GAAGJ,MAAM;AAC/B,IAAMK,QAAQ,GAAG,EAAE,GAAGL,MAAM;AAC5B,IAAMM,OAAO,GAAG,EAAE,GAAGN,MAAM;AAC3B,IAAMO,UAAU,GAAG,CAAC,GAAGD,OAAO;AAC9B,IAAME,QAAQ,GAAG,CAAC,GAAGF,OAAO;AAC5B,IAAMG,WAAW,GAAG,EAAE,GAAGH,OAAO;AAChC,IAAMI,WAAW,GAAG,EAAE,GAAGJ,OAAO;AAChC,IAAMK,YAAY,GAAG,CAAC,GAAGD,WAAW;AACpC,IAAME,aAAa,GAAG,EAAE,GAAGF,WAAW;AACtC,IAAMG,YAAY,GAAG,GAAG,GAAGH,WAAW;AACtC,IAAMI,qBAAqB,GAAG;EAC1Bd,MAAM,EAAED,cAAc;EACtBE,SAAS,EAAEF,cAAc;EACzBG,QAAQ,EAAEF,MAAM;EAChBG,OAAO,EAAEH,MAAM;EACfI,WAAW,EAAEH,SAAS;EACtBI,QAAQ,EAAEH,QAAQ;EAClBI,OAAO,EAAEH,OAAO;EAChBI,UAAU,EAAEF,QAAQ;EACpBG,QAAQ,EAAEF,OAAO;EACjBG,WAAW,EAAEF,UAAU;EACvBQ,GAAG,EAAEP,QAAQ;EACbQ,IAAI,EAAEN,WAAW;EACjBO,KAAK,EAAEN,YAAY;EACnBO,IAAI,EAAEN;AACV,CAAC;AACD;AACA;AACA,OAAO,IAAMO,8BAA8B,GAAG,SAAjCA,8BAA8BA,CAAIvC,GAAG,EAAEC,GAAG,EAAK;EACxD,IAAI,CAACY,MAAM,CAACC,QAAQ,CAACd,GAAG,CAAC,IAAI,CAACa,MAAM,CAACC,QAAQ,CAACb,GAAG,CAAC,IAAID,GAAG,GAAGC,GAAG,EAAE;IAC7D,OAAO;MACHuC,QAAQ,EAAE,IAAI;MACdC,QAAQ,EAAE;IACd,CAAC;EACL;EACA,IAAMC,IAAI,GAAGzC,GAAG,GAAGD,GAAG;EACtB,IAAI2C,SAAS,GAAG,EAAE;EAClB,QAAQ,IAAI;IACR,KAAKD,IAAI,GAAGtB,MAAM;MACduB,SAAS,GAAG,QAAQ;MACpB;IACJ,KAAKD,IAAI,GAAGpB,QAAQ;MAChBqB,SAAS,GAAG,UAAU;MACtB;IACJ,KAAKD,IAAI,GAAGnB,OAAO;MACfoB,SAAS,GAAG,SAAS;MACrB;IACJ,KAAKD,IAAI,GAAGlB,WAAW;MACnBmB,SAAS,GAAG,aAAa;MACzB;IACJ,KAAKD,IAAI,GAAGjB,QAAQ;MAChBkB,SAAS,GAAG,UAAU;MACtB;IACJ,KAAKD,IAAI,GAAGhB,OAAO;MACfiB,SAAS,GAAG,SAAS;MACrB;IACJ,KAAKD,IAAI,GAAGf,UAAU;MAClBgB,SAAS,GAAG,YAAY;MACxB;IACJ,KAAKD,IAAI,GAAGd,QAAQ;MAChBe,SAAS,GAAG,UAAU;MACtB;IACJ,KAAKD,IAAI,GAAGb,WAAW;MACnBc,SAAS,GAAG,aAAa;MACzB;IACJ,KAAKD,IAAI,GAAGZ,WAAW;MACnBa,SAAS,GAAG,KAAK;MACjB;IACJ,KAAKD,IAAI,GAAGX,YAAY;MACpBY,SAAS,GAAG,MAAM;MAClB;IACJ,KAAKD,IAAI,GAAGV,aAAa;MACrBW,SAAS,GAAG,OAAO;MACnB;IACJ,KAAKD,IAAI,GAAGT,YAAY;MACpBU,SAAS,GAAG,OAAO;MACnB;IACJ;MACIA,SAAS,GAAG,MAAM;EAC1B;EACA,IAAMF,QAAQ,GAAGP,qBAAqB,CAACS,SAAS,CAAC;EACjD,IAAMH,QAAQ,GAAGxC,GAAG,GAAIA,GAAG,GAAGyC,QAAS;EACvC,OAAO;IAAED,QAAQ,EAARA,QAAQ;IAAEC,QAAQ,EAARA;EAAS,CAAC;AACjC,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,IAAMG,cAAc,GAAG,SAAjBA,cAAcA,CAAI9C,IAAI,EAAEY,OAAO,EAAK;EAC7C,IAAAmC,sBAAA,GAAqBhD,2BAA2B,CAACC,IAAI,EAAEY,OAAO,CAAC;IAAvDV,GAAG,GAAA6C,sBAAA,CAAH7C,GAAG;IAAEC,GAAG,GAAA4C,sBAAA,CAAH5C,GAAG;EAChB,IAAA6C,qBAAA,GAA+BP,8BAA8B,CAACvC,GAAG,EAAEC,GAAG,CAAC;IAA/DuC,QAAQ,GAAAM,qBAAA,CAARN,QAAQ;IAAEC,QAAQ,GAAAK,qBAAA,CAARL,QAAQ;EAC1B,IAAMM,KAAK,GAAG,EAAE;EAChB,IAAI,CAAClC,MAAM,CAACC,QAAQ,CAAC0B,QAAQ,CAAC,IAC1B,CAAC3B,MAAM,CAACC,QAAQ,CAAC2B,QAAQ,CAAC,IAC1B,CAAC5B,MAAM,CAACC,QAAQ,CAACd,GAAG,CAAC,IACrB,CAACa,MAAM,CAACC,QAAQ,CAACb,GAAG,CAAC,EAAE;IACvB,OAAO8C,KAAK;EAChB;EACA,KAAK,IAAIC,CAAC,GAAGR,QAAQ,EAAEQ,CAAC,IAAI/C,GAAG,EAAE+C,CAAC,IAAIP,QAAQ,EAAE;IAC5CM,KAAK,CAACE,IAAI,CAACD,CAAC,CAAC;EACjB;EACA,OAAOD,KAAK;AAChB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}