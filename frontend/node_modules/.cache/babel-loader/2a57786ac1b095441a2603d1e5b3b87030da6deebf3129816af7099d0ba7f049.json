{"ast":null,"code":"import _objectSpread from \"/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport React from \"react\";\nimport { CartesianGrid, Legend, ResponsiveContainer, Scatter, ScatterChart, Tooltip, XAxis, YAxis } from \"recharts\";\nimport { calculateDomainEdges, calculateTicks, localTimeFormatter } from \"./helpers\";\n/**\n * We wrap the ScatterPlot Recharts component for use in linear timeline views. This is more useful than the\n * wrapper for linecharts for this specific use case of having \"lanes\" of events and their timestamps.\n */\n// TODO(smonero): add tests for this component\nvar LinearTimeline = function LinearTimeline(_ref) {\n  var data = _ref.data,\n    _ref$xAxisDataKey = _ref.xAxisDataKey,\n    xAxisDataKey = _ref$xAxisDataKey === void 0 ? \"timestamp\" : _ref$xAxisDataKey,\n    _ref$regularIntervalT = _ref.regularIntervalTicks,\n    regularIntervalTicks = _ref$regularIntervalT === void 0 ? true : _ref$regularIntervalT,\n    _ref$tickFormatterFun = _ref.tickFormatterFunc,\n    tickFormatterFunc = _ref$tickFormatterFun === void 0 ? localTimeFormatter : _ref$tickFormatterFun,\n    _ref$legend = _ref.legend,\n    legend = _ref$legend === void 0 ? true : _ref$legend,\n    _ref$tooltipFormatter = _ref.tooltipFormatterFunc,\n    tooltipFormatterFunc = _ref$tooltipFormatter === void 0 ? null : _ref$tooltipFormatter,\n    _ref$stylingProps = _ref.stylingProps,\n    stylingProps = _ref$stylingProps === void 0 ? {} : _ref$stylingProps;\n  var _a, _b;\n  var combinedData = Object.keys(data).reduce(function (acc, lane) {\n    return [].concat(_toConsumableArray(acc), _toConsumableArray(data[lane].points));\n  }, []);\n  var _calculateDomainEdges = calculateDomainEdges(combinedData, xAxisDataKey, 0.2),\n    _calculateDomainEdges2 = _slicedToArray(_calculateDomainEdges, 2),\n    xAxisDomainMin = _calculateDomainEdges2[0],\n    xAxisDomainMax = _calculateDomainEdges2[1];\n  var ticks = [];\n  // If we want regularly spaced interval ticks along the X-Axis, we need to calculate the ticks ourselves,\n  // rather than letting Recharts calculate them for us. We calculate them using the distance between the\n  // max and min of the timestamps.\n  if (regularIntervalTicks) {\n    ticks = calculateTicks(combinedData, xAxisDataKey);\n  }\n  // Because we can't rely on using \"category\" for the Y-Axis, we need to assign Ids (based off the index)\n  var mappingOfLaneIdsToNames = {};\n  var dataWithIds = Object.keys(data).map(function (key, index) {\n    mappingOfLaneIdsToNames[index] = key;\n    var thePoints = data[key].points;\n    var pointsWithId = thePoints.map(function (point) {\n      return _objectSpread(_objectSpread({}, point), {}, {\n        laneID: index\n      });\n    });\n    return {\n      points: pointsWithId,\n      shape: data[key].shape,\n      color: data[key].color,\n      laneID: index\n    };\n  });\n  var formatIdsToNames = function formatIdsToNames(value) {\n    return React.createElement(\"span\", null, mappingOfLaneIdsToNames[value]);\n  };\n  // TODO: Allow for proper styling and make things less hacky than \"payload[0]\"\n  var defaultFormatTooltip = function defaultFormatTooltip(_ref2) {\n    var active = _ref2.active,\n      payload = _ref2.payload;\n    if (active) {\n      return React.createElement(\"div\", {\n        style: {\n          backgroundColor: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.tooltipBackgroundColor,\n          color: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.tooltipTextColor\n        }\n      }, localTimeFormatter(payload[0].value));\n    }\n    return null;\n  };\n  return React.createElement(ResponsiveContainer, {\n    width: \"100%\",\n    height: \"100%\"\n  }, React.createElement(ScatterChart, null, React.createElement(CartesianGrid, {\n    fill: (_a = stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridBackgroundColor) !== null && _a !== void 0 ? _a : \"black\",\n    stroke: (_b = stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridStroke) !== null && _b !== void 0 ? _b : \"white\"\n  }), React.createElement(XAxis, {\n    dataKey: xAxisDataKey,\n    type: \"number\",\n    domain: [xAxisDomainMin, xAxisDomainMax],\n    tickFormatter: tickFormatterFunc,\n    allowDataOverflow: true,\n    ticks: regularIntervalTicks ? ticks : null,\n    stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.xAxisStroke\n  }), React.createElement(YAxis, {\n    dataKey: \"laneID\",\n    type: \"number\",\n    padding: {\n      bottom: 30,\n      top: 30\n    },\n    hide: true\n  }), React.createElement(Tooltip, {\n    content: tooltipFormatterFunc !== null && tooltipFormatterFunc !== void 0 ? tooltipFormatterFunc : defaultFormatTooltip\n  }), legend ? React.createElement(Legend, {\n    iconSize: 18,\n    formatter: formatIdsToNames\n  }) : null, Object.keys(dataWithIds).map(function (lane) {\n    var _a, _b, _c;\n    var points = dataWithIds[lane].points;\n    return React.createElement(Scatter, {\n      key: lane,\n      data: points,\n      name: lane,\n      shape: (_a = dataWithIds[lane].shape) !== null && _a !== void 0 ? _a : \"circle\",\n      fill: (_b = dataWithIds[lane].color) !== null && _b !== void 0 ? _b : \"null\",\n      legendType: (_c = dataWithIds[lane].shape) !== null && _c !== void 0 ? _c : \"circle\"\n    });\n  })));\n};\nexport default LinearTimeline;","map":{"version":3,"names":["React","CartesianGrid","Legend","ResponsiveContainer","Scatter","ScatterChart","Tooltip","XAxis","YAxis","calculateDomainEdges","calculateTicks","localTimeFormatter","LinearTimeline","_ref","data","_ref$xAxisDataKey","xAxisDataKey","_ref$regularIntervalT","regularIntervalTicks","_ref$tickFormatterFun","tickFormatterFunc","_ref$legend","legend","_ref$tooltipFormatter","tooltipFormatterFunc","_ref$stylingProps","stylingProps","_a","_b","combinedData","Object","keys","reduce","acc","lane","concat","_toConsumableArray","points","_calculateDomainEdges","_calculateDomainEdges2","_slicedToArray","xAxisDomainMin","xAxisDomainMax","ticks","mappingOfLaneIdsToNames","dataWithIds","map","key","index","thePoints","pointsWithId","point","_objectSpread","laneID","shape","color","formatIdsToNames","value","createElement","defaultFormatTooltip","_ref2","active","payload","style","backgroundColor","tooltipBackgroundColor","tooltipTextColor","width","height","fill","gridBackgroundColor","stroke","gridStroke","dataKey","type","domain","tickFormatter","allowDataOverflow","xAxisStroke","padding","bottom","top","hide","content","iconSize","formatter","_c","name","legendType"],"sources":["/home/daniel/go/src/github.com/DanielYevelkin/clutch-custom-gateway/frontend/node_modules/@clutch-sh/core/dist/Charts/linearTimeline.js"],"sourcesContent":["import React from \"react\";\nimport { CartesianGrid, Legend, ResponsiveContainer, Scatter, ScatterChart, Tooltip, XAxis, YAxis, } from \"recharts\";\nimport { calculateDomainEdges, calculateTicks, localTimeFormatter } from \"./helpers\";\n/**\n * We wrap the ScatterPlot Recharts component for use in linear timeline views. This is more useful than the\n * wrapper for linecharts for this specific use case of having \"lanes\" of events and their timestamps.\n */\n// TODO(smonero): add tests for this component\nconst LinearTimeline = ({ data, xAxisDataKey = \"timestamp\", regularIntervalTicks = true, tickFormatterFunc = localTimeFormatter, legend = true, \n// Note that we don't set the default tooltipFormatter here because we pass the styling vals into the default\ntooltipFormatterFunc = null, stylingProps = {}, }) => {\n    var _a, _b;\n    const combinedData = Object.keys(data).reduce((acc, lane) => {\n        return [...acc, ...data[lane].points];\n    }, []);\n    const [xAxisDomainMin, xAxisDomainMax] = calculateDomainEdges(combinedData, xAxisDataKey, 0.2);\n    let ticks = [];\n    // If we want regularly spaced interval ticks along the X-Axis, we need to calculate the ticks ourselves,\n    // rather than letting Recharts calculate them for us. We calculate them using the distance between the\n    // max and min of the timestamps.\n    if (regularIntervalTicks) {\n        ticks = calculateTicks(combinedData, xAxisDataKey);\n    }\n    // Because we can't rely on using \"category\" for the Y-Axis, we need to assign Ids (based off the index)\n    const mappingOfLaneIdsToNames = {};\n    const dataWithIds = Object.keys(data).map((key, index) => {\n        mappingOfLaneIdsToNames[index] = key;\n        const thePoints = data[key].points;\n        const pointsWithId = thePoints.map(point => {\n            return {\n                ...point,\n                laneID: index,\n            };\n        });\n        return {\n            points: pointsWithId,\n            shape: data[key].shape,\n            color: data[key].color,\n            laneID: index,\n        };\n    });\n    const formatIdsToNames = (value) => {\n        return React.createElement(\"span\", null, mappingOfLaneIdsToNames[value]);\n    };\n    // TODO: Allow for proper styling and make things less hacky than \"payload[0]\"\n    const defaultFormatTooltip = ({ active, payload }) => {\n        if (active) {\n            return (React.createElement(\"div\", { style: {\n                    backgroundColor: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.tooltipBackgroundColor,\n                    color: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.tooltipTextColor,\n                } }, localTimeFormatter(payload[0].value)));\n        }\n        return null;\n    };\n    return (React.createElement(ResponsiveContainer, { width: \"100%\", height: \"100%\" },\n        React.createElement(ScatterChart, null,\n            React.createElement(CartesianGrid, { fill: (_a = stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridBackgroundColor) !== null && _a !== void 0 ? _a : \"black\", stroke: (_b = stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.gridStroke) !== null && _b !== void 0 ? _b : \"white\" }),\n            React.createElement(XAxis, { dataKey: xAxisDataKey, type: \"number\", domain: [xAxisDomainMin, xAxisDomainMax], tickFormatter: tickFormatterFunc, allowDataOverflow: true, ticks: regularIntervalTicks ? ticks : null, stroke: stylingProps === null || stylingProps === void 0 ? void 0 : stylingProps.xAxisStroke }),\n            React.createElement(YAxis, { dataKey: \"laneID\", type: \"number\", padding: { bottom: 30, top: 30 }, hide: true }),\n            React.createElement(Tooltip, { content: tooltipFormatterFunc !== null && tooltipFormatterFunc !== void 0 ? tooltipFormatterFunc : defaultFormatTooltip }),\n            legend ? React.createElement(Legend, { iconSize: 18, formatter: formatIdsToNames }) : null,\n            Object.keys(dataWithIds).map(lane => {\n                var _a, _b, _c;\n                const { points } = dataWithIds[lane];\n                return (React.createElement(Scatter, { key: lane, data: points, name: lane, shape: (_a = dataWithIds[lane].shape) !== null && _a !== void 0 ? _a : \"circle\", fill: (_b = dataWithIds[lane].color) !== null && _b !== void 0 ? _b : \"null\", legendType: (_c = dataWithIds[lane].shape) !== null && _c !== void 0 ? _c : \"circle\" }));\n            }))));\n};\nexport default LinearTimeline;\n"],"mappings":";;;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,aAAa,EAAEC,MAAM,EAAEC,mBAAmB,EAAEC,OAAO,EAAEC,YAAY,EAAEC,OAAO,EAAEC,KAAK,EAAEC,KAAK,QAAS,UAAU;AACpH,SAASC,oBAAoB,EAAEC,cAAc,EAAEC,kBAAkB,QAAQ,WAAW;AACpF;AACA;AACA;AACA;AACA;AACA,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAAC,IAAA,EAEkC;EAAA,IAF5BC,IAAI,GAAAD,IAAA,CAAJC,IAAI;IAAAC,iBAAA,GAAAF,IAAA,CAAEG,YAAY;IAAZA,YAAY,GAAAD,iBAAA,cAAG,WAAW,GAAAA,iBAAA;IAAAE,qBAAA,GAAAJ,IAAA,CAAEK,oBAAoB;IAApBA,oBAAoB,GAAAD,qBAAA,cAAG,IAAI,GAAAA,qBAAA;IAAAE,qBAAA,GAAAN,IAAA,CAAEO,iBAAiB;IAAjBA,iBAAiB,GAAAD,qBAAA,cAAGR,kBAAkB,GAAAQ,qBAAA;IAAAE,WAAA,GAAAR,IAAA,CAAES,MAAM;IAANA,MAAM,GAAAD,WAAA,cAAG,IAAI,GAAAA,WAAA;IAAAE,qBAAA,GAAAV,IAAA,CAE9IW,oBAAoB;IAApBA,oBAAoB,GAAAD,qBAAA,cAAG,IAAI,GAAAA,qBAAA;IAAAE,iBAAA,GAAAZ,IAAA,CAAEa,YAAY;IAAZA,YAAY,GAAAD,iBAAA,cAAG,CAAC,CAAC,GAAAA,iBAAA;EAC1C,IAAIE,EAAE,EAAEC,EAAE;EACV,IAAMC,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACjB,IAAI,CAAC,CAACkB,MAAM,CAAC,UAACC,GAAG,EAAEC,IAAI,EAAK;IACzD,UAAAC,MAAA,CAAAC,kBAAA,CAAWH,GAAG,GAAAG,kBAAA,CAAKtB,IAAI,CAACoB,IAAI,CAAC,CAACG,MAAM;EACxC,CAAC,EAAE,EAAE,CAAC;EACN,IAAAC,qBAAA,GAAyC7B,oBAAoB,CAACoB,YAAY,EAAEb,YAAY,EAAE,GAAG,CAAC;IAAAuB,sBAAA,GAAAC,cAAA,CAAAF,qBAAA;IAAvFG,cAAc,GAAAF,sBAAA;IAAEG,cAAc,GAAAH,sBAAA;EACrC,IAAII,KAAK,GAAG,EAAE;EACd;EACA;EACA;EACA,IAAIzB,oBAAoB,EAAE;IACtByB,KAAK,GAAGjC,cAAc,CAACmB,YAAY,EAAEb,YAAY,CAAC;EACtD;EACA;EACA,IAAM4B,uBAAuB,GAAG,CAAC,CAAC;EAClC,IAAMC,WAAW,GAAGf,MAAM,CAACC,IAAI,CAACjB,IAAI,CAAC,CAACgC,GAAG,CAAC,UAACC,GAAG,EAAEC,KAAK,EAAK;IACtDJ,uBAAuB,CAACI,KAAK,CAAC,GAAGD,GAAG;IACpC,IAAME,SAAS,GAAGnC,IAAI,CAACiC,GAAG,CAAC,CAACV,MAAM;IAClC,IAAMa,YAAY,GAAGD,SAAS,CAACH,GAAG,CAAC,UAAAK,KAAK,EAAI;MACxC,OAAAC,aAAA,CAAAA,aAAA,KACOD,KAAK;QACRE,MAAM,EAAEL;MAAK;IAErB,CAAC,CAAC;IACF,OAAO;MACHX,MAAM,EAAEa,YAAY;MACpBI,KAAK,EAAExC,IAAI,CAACiC,GAAG,CAAC,CAACO,KAAK;MACtBC,KAAK,EAAEzC,IAAI,CAACiC,GAAG,CAAC,CAACQ,KAAK;MACtBF,MAAM,EAAEL;IACZ,CAAC;EACL,CAAC,CAAC;EACF,IAAMQ,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIC,KAAK,EAAK;IAChC,OAAOzD,KAAK,CAAC0D,aAAa,CAAC,MAAM,EAAE,IAAI,EAAEd,uBAAuB,CAACa,KAAK,CAAC,CAAC;EAC5E,CAAC;EACD;EACA,IAAME,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAAC,KAAA,EAA4B;IAAA,IAAtBC,MAAM,GAAAD,KAAA,CAANC,MAAM;MAAEC,OAAO,GAAAF,KAAA,CAAPE,OAAO;IAC3C,IAAID,MAAM,EAAE;MACR,OAAQ7D,KAAK,CAAC0D,aAAa,CAAC,KAAK,EAAE;QAAEK,KAAK,EAAE;UACpCC,eAAe,EAAEtC,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACuC,sBAAsB;UAChHV,KAAK,EAAE7B,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACwC;QACpF;MAAE,CAAC,EAAEvD,kBAAkB,CAACmD,OAAO,CAAC,CAAC,CAAC,CAACL,KAAK,CAAC,CAAC;IAClD;IACA,OAAO,IAAI;EACf,CAAC;EACD,OAAQzD,KAAK,CAAC0D,aAAa,CAACvD,mBAAmB,EAAE;IAAEgE,KAAK,EAAE,MAAM;IAAEC,MAAM,EAAE;EAAO,CAAC,EAC9EpE,KAAK,CAAC0D,aAAa,CAACrD,YAAY,EAAE,IAAI,EAClCL,KAAK,CAAC0D,aAAa,CAACzD,aAAa,EAAE;IAAEoE,IAAI,EAAE,CAAC1C,EAAE,GAAGD,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAAC4C,mBAAmB,MAAM,IAAI,IAAI3C,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,OAAO;IAAE4C,MAAM,EAAE,CAAC3C,EAAE,GAAGF,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAAC8C,UAAU,MAAM,IAAI,IAAI5C,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG;EAAQ,CAAC,CAAC,EACvU5B,KAAK,CAAC0D,aAAa,CAACnD,KAAK,EAAE;IAAEkE,OAAO,EAAEzD,YAAY;IAAE0D,IAAI,EAAE,QAAQ;IAAEC,MAAM,EAAE,CAAClC,cAAc,EAAEC,cAAc,CAAC;IAAEkC,aAAa,EAAExD,iBAAiB;IAAEyD,iBAAiB,EAAE,IAAI;IAAElC,KAAK,EAAEzB,oBAAoB,GAAGyB,KAAK,GAAG,IAAI;IAAE4B,MAAM,EAAE7C,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,YAAY,CAACoD;EAAY,CAAC,CAAC,EACpT9E,KAAK,CAAC0D,aAAa,CAAClD,KAAK,EAAE;IAAEiE,OAAO,EAAE,QAAQ;IAAEC,IAAI,EAAE,QAAQ;IAAEK,OAAO,EAAE;MAAEC,MAAM,EAAE,EAAE;MAAEC,GAAG,EAAE;IAAG,CAAC;IAAEC,IAAI,EAAE;EAAK,CAAC,CAAC,EAC/GlF,KAAK,CAAC0D,aAAa,CAACpD,OAAO,EAAE;IAAE6E,OAAO,EAAE3D,oBAAoB,KAAK,IAAI,IAAIA,oBAAoB,KAAK,KAAK,CAAC,GAAGA,oBAAoB,GAAGmC;EAAqB,CAAC,CAAC,EACzJrC,MAAM,GAAGtB,KAAK,CAAC0D,aAAa,CAACxD,MAAM,EAAE;IAAEkF,QAAQ,EAAE,EAAE;IAAEC,SAAS,EAAE7B;EAAiB,CAAC,CAAC,GAAG,IAAI,EAC1F1B,MAAM,CAACC,IAAI,CAACc,WAAW,CAAC,CAACC,GAAG,CAAC,UAAAZ,IAAI,EAAI;IACjC,IAAIP,EAAE,EAAEC,EAAE,EAAE0D,EAAE;IACd,IAAQjD,MAAM,GAAKQ,WAAW,CAACX,IAAI,CAAC,CAA5BG,MAAM;IACd,OAAQrC,KAAK,CAAC0D,aAAa,CAACtD,OAAO,EAAE;MAAE2C,GAAG,EAAEb,IAAI;MAAEpB,IAAI,EAAEuB,MAAM;MAAEkD,IAAI,EAAErD,IAAI;MAAEoB,KAAK,EAAE,CAAC3B,EAAE,GAAGkB,WAAW,CAACX,IAAI,CAAC,CAACoB,KAAK,MAAM,IAAI,IAAI3B,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,QAAQ;MAAE0C,IAAI,EAAE,CAACzC,EAAE,GAAGiB,WAAW,CAACX,IAAI,CAAC,CAACqB,KAAK,MAAM,IAAI,IAAI3B,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,MAAM;MAAE4D,UAAU,EAAE,CAACF,EAAE,GAAGzC,WAAW,CAACX,IAAI,CAAC,CAACoB,KAAK,MAAM,IAAI,IAAIgC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG;IAAS,CAAC,CAAC;EACtU,CAAC,CAAC,CAAC,CAAC;AAChB,CAAC;AACD,eAAe1E,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}